'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));

var TWITCH_EMBED_URL = 'https://embed.twitch.tv/embed/v1.js';
var TWITCH_CHAT_URL = 'https://www.twitch.tv/embed';
var TWITCH_CLIP_URL = 'https://clips.twitch.tv/embed';
var TWITCH_PLAYER_URL = 'https://player.twitch.tv/js/embed/v1.js';

var CHAT_DEFAULT_HEIGHT = 500;
var CHAT_DEFAULT_WIDTH = 350;
var MEDIA_DEFAULT_HEIGHT = 480;
var MEDIA_DEFAULT_WIDTH = 940;

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var parseParentQuery = function parseParentQuery(parent) {
  return '&parent=' + [window.location.hostname].concat(toConsumableArray(parent)).join('&parent=');
};

var getUnknownProps = function getUnknownProps(props, propTypes) {
  return Object.keys(props).reduce(function (unknown, prop) {
    if (propTypes.hasOwnProperty(prop)) {
      return unknown;
    }

    unknown[prop] = props[prop];
    return unknown;
  }, {});
};

var scriptElement = null;

var loadScript = function loadScript() {
  scriptElement = document.createElement('script');
  scriptElement.setAttribute('type', 'text/javascript');
  scriptElement.setAttribute('src', TWITCH_EMBED_URL);
  document.body.appendChild(scriptElement);
};

var propTypes = {
  id: PropTypes.string,
  allowFullscreen: PropTypes.bool,
  channel: PropTypes.string.isRequired,
  fontSize: PropTypes.oneOf(['small', 'medium', 'large']),
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  withChat: PropTypes.bool,
  theme: PropTypes.oneOf(['light', 'dark']),
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  onAuthenticate: PropTypes.func,
  onVideoPlay: PropTypes.func,
  onVideoPause: PropTypes.func,
  onVideoReady: PropTypes.func,
  autoplay: PropTypes.bool,
  muted: PropTypes.bool,
  parent: PropTypes.arrayOf(PropTypes.string)
};

var defaultProps = {
  id: 'twitch-embed',
  allowFullscreen: true,
  fontSize: 'small',
  height: MEDIA_DEFAULT_HEIGHT,
  withChat: true,
  theme: 'light',
  width: MEDIA_DEFAULT_WIDTH,
  onAuthenticate: function onAuthenticate() {
    return null;
  },
  onVideoPlay: function onVideoPlay() {
    return null;
  },
  onVideoPause: function onVideoPause() {
    return null;
  },
  onVideoReady: function onVideoReady() {
    return null;
  },
  autoplay: true,
  muted: false,
  parent: []
};

var TwitchEmbed = function (_Component) {
  inherits(TwitchEmbed, _Component);

  function TwitchEmbed() {
    classCallCheck(this, TwitchEmbed);
    return possibleConstructorReturn(this, (TwitchEmbed.__proto__ || Object.getPrototypeOf(TwitchEmbed)).apply(this, arguments));
  }

  createClass(TwitchEmbed, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this._validateProps();

      if (window.Twitch && window.Twitch.Embed) {
        return this._createEmbed();
      }

      if (!scriptElement) {
        loadScript();
      }

      scriptElement.addEventListener('load', function () {
        _this2._createEmbed();
      });
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      var _this3 = this;

      this._validateProps();

      if (prevProps.withChat) {
        this.embed = null;
        this.player = null;
        document.getElementById(prevProps.id).innerHTML = '';
        return this._createEmbed();
      }

      var updatedPropsExceptChannel = Object.keys(prevProps).reduce(function (updated, prop) {
        if (prop === 'channel') {
          return updated;
        }

        if (prevProps[prop] !== _this3.props[prop]) {
          updated.push(prop);
        }

        return updated;
      }, []);

      if (updatedPropsExceptChannel.length > 0) {
        this.embed = null;
        this.player = null;
        document.getElementById(prevProps.id).innerHTML = '';
        return this._createEmbed();
      }

      if (prevProps.channel !== this.props.channel) {
        this.player.setChannel(this.props.channel);
      }
    }
  }, {
    key: '_createEmbed',
    value: function _createEmbed() {
      this.embed = new window.Twitch.Embed(this.props.id, {
        allowfullscreen: this.props.allowFullscreen,
        channel: this.props.channel,
        'font-size': this.props.fontSize,
        height: '100%',
        layout: this.props.withChat ? 'video-with-chat' : 'video',
        theme: this.props.theme,
        width: '100%',
        parent: this.props.parent
      });

      this._addEventListeners();
    }
  }, {
    key: '_addEventListeners',
    value: function _addEventListeners() {
      var _this4 = this;

      this.embed.addEventListener(window.Twitch.Embed.AUTHENTICATE, this.props.onAuthenticate);
      this.embed.addEventListener(window.Twitch.Embed.VIDEO_PLAY, this.props.onVideoPlay);
      this.embed.addEventListener(window.Twitch.Embed.VIDEO_PAUSE, this.props.onVideoPause);
      this.embed.addEventListener(window.Twitch.Embed.VIDEO_READY, function () {
        var _props = _this4.props,
            autoplay = _props.autoplay,
            muted = _props.muted;

        _this4.player = _this4.embed.getPlayer();

        if (muted) {
          _this4.player.setVolume(0);
        }

        if (!autoplay) {
          _this4.player.pause();
        }

        _this4.props.onVideoReady(_this4.player);
      });
    }
  }, {
    key: '_validateProps',
    value: function _validateProps() {
      if (!this.props.channel) {
        throw new Error('A channel prop must be supplied to TwitchEmbed!');
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var unknownProps = getUnknownProps(this.props, propTypes);

      return React__default.createElement('div', _extends({ style: { width: this.props.width, height: this.props.height }, id: this.props.id }, unknownProps));
    }
  }]);
  return TwitchEmbed;
}(React.Component);

TwitchEmbed.propTypes = propTypes;
TwitchEmbed.defaultProps = defaultProps;

var propTypes$1 = {
  channel: PropTypes.string.isRequired,
  id: PropTypes.string,
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  theme: PropTypes.oneOf(['light', 'dark']),
  parent: PropTypes.arrayOf(PropTypes.string),
  migration: PropTypes.bool
};

var defaultProps$1 = {
  id: 'twitch-chat-embed',
  height: CHAT_DEFAULT_HEIGHT,
  width: CHAT_DEFAULT_WIDTH,
  theme: 'light',
  migration: true,
  parent: []
};

var TwitchChat = function (_Component) {
  inherits(TwitchChat, _Component);

  function TwitchChat() {
    classCallCheck(this, TwitchChat);
    return possibleConstructorReturn(this, (TwitchChat.__proto__ || Object.getPrototypeOf(TwitchChat)).apply(this, arguments));
  }

  createClass(TwitchChat, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._validateProps();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      this._validateProps();
    }
  }, {
    key: '_validateProps',
    value: function _validateProps() {
      if (!this.props.channel) {
        throw new Error('A channel prop must be supplied to TwitchChat!');
      }
    }
  }, {
    key: '_createEmbedURL',
    value: function _createEmbedURL() {
      var _props = this.props,
          channel = _props.channel,
          theme = _props.theme,
          parent = _props.parent,
          migration = _props.migration;


      var themeQuery = theme === 'dark' ? '?darkpopout' : '';
      var migrationFirstChar = theme !== 'dark' ? '?' : '&';
      return TWITCH_CHAT_URL + '/' + channel + '/chat' + themeQuery + migrationFirstChar + 'migration=' + migration.toString() + parseParentQuery(parent);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          height = _props2.height,
          id = _props2.id,
          width = _props2.width;

      var unknownProps = getUnknownProps(this.props, propTypes$1);

      return React__default.createElement('iframe', _extends({
        title: 'Twitch Chat - ' + id,
        id: id,
        src: this._createEmbedURL(),
        height: height,
        width: width,
        frameBorder: 0
      }, unknownProps));
    }
  }]);
  return TwitchChat;
}(React.Component);

TwitchChat.propTypes = propTypes$1;
TwitchChat.defaultProps = defaultProps$1;

var propTypes$2 = {
  clip: PropTypes.string.isRequired,
  id: PropTypes.string,
  autoplay: PropTypes.bool,
  muted: PropTypes.bool,
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  allowFullscreen: PropTypes.bool,
  parent: PropTypes.arrayOf(PropTypes.string),
  migration: PropTypes.bool
};

var defaultProps$2 = {
  id: 'twitch-clip-embed',
  autoplay: true,
  muted: false,
  height: MEDIA_DEFAULT_HEIGHT,
  width: MEDIA_DEFAULT_WIDTH,
  allowFullscreen: true,
  migration: true,
  parent: []
};

var TwitchClip = function (_Component) {
  inherits(TwitchClip, _Component);

  function TwitchClip() {
    classCallCheck(this, TwitchClip);
    return possibleConstructorReturn(this, (TwitchClip.__proto__ || Object.getPrototypeOf(TwitchClip)).apply(this, arguments));
  }

  createClass(TwitchClip, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._validateProps();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      this._validateProps();
    }
  }, {
    key: '_validateProps',
    value: function _validateProps() {
      if (!this.props.clip) {
        throw new Error('A clip prop must be supplied to TwitchClip!');
      }
    }
  }, {
    key: '_createEmbedURL',
    value: function _createEmbedURL() {
      var _props = this.props,
          clip = _props.clip,
          autoplay = _props.autoplay,
          muted = _props.muted,
          parent = _props.parent,
          migration = _props.migration;


      return TWITCH_CLIP_URL + '?clip=' + clip + '&autoplay=' + autoplay + '&muted=' + muted + '&migration=' + migration.toString() + parseParentQuery(parent);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          id = _props2.id,
          height = _props2.height,
          width = _props2.width,
          allowFullscreen = _props2.allowFullscreen;

      var unknownProps = getUnknownProps(this.props, propTypes$2);

      return React__default.createElement('iframe', _extends({
        title: 'Twitch Clip Embed - ' + id,
        src: this._createEmbedURL(),
        id: id,
        height: height,
        width: width,
        allowFullScreen: allowFullscreen,
        frameBorder: 0
      }, unknownProps));
    }
  }]);
  return TwitchClip;
}(React.Component);

TwitchClip.propTypes = propTypes$2;
TwitchClip.defaultProps = defaultProps$2;

var mediaProps = ['channel', 'collection', 'video'];
var scriptElement$1 = null;

var loadScript$1 = function loadScript() {
  scriptElement$1 = document.createElement('script');
  scriptElement$1.setAttribute('type', 'text/javascript');
  scriptElement$1.setAttribute('src', TWITCH_PLAYER_URL);
  document.body.appendChild(scriptElement$1);
};

var propTypes$3 = {
  id: PropTypes.string,
  channel: PropTypes.string,
  collection: PropTypes.string,
  video: PropTypes.string,
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  playsInline: PropTypes.bool,
  autoplay: PropTypes.bool,
  muted: PropTypes.bool,
  allowFullscreen: PropTypes.bool,
  time: PropTypes.string,
  hideControls: PropTypes.bool,
  onEnded: PropTypes.func,
  onPause: PropTypes.func,
  onPlay: PropTypes.func,
  onPlaybackBlocked: PropTypes.func,
  onPlaying: PropTypes.func,
  onOffline: PropTypes.func,
  onOnline: PropTypes.func,
  onReady: PropTypes.func,
  parent: PropTypes.arrayOf(PropTypes.string)
};

var defaultProps$3 = {
  id: 'twitch-player-embed',
  channel: null,
  collection: null,
  video: null,
  height: MEDIA_DEFAULT_HEIGHT,
  width: MEDIA_DEFAULT_WIDTH,
  playsInline: true,
  autoplay: true,
  muted: false,
  allowFullscreen: true,
  time: '0h0m0s',
  hideControls: false,
  onEnded: function onEnded() {
    return null;
  },
  onPause: function onPause() {
    return null;
  },
  onPlay: function onPlay() {
    return null;
  },
  onPlaybackBlocked: function onPlaybackBlocked() {
    return null;
  },
  onPlaying: function onPlaying() {
    return null;
  },
  onOffline: function onOffline() {
    return null;
  },
  onOnline: function onOnline() {
    return null;
  },
  onReady: function onReady() {
    return null;
  },
  parent: []
};

var TwitchPlayer = function (_Component) {
  inherits(TwitchPlayer, _Component);

  function TwitchPlayer() {
    classCallCheck(this, TwitchPlayer);
    return possibleConstructorReturn(this, (TwitchPlayer.__proto__ || Object.getPrototypeOf(TwitchPlayer)).apply(this, arguments));
  }

  createClass(TwitchPlayer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this._validateProps();

      if (window.Twitch && window.Twitch.Player) {
        return this._createPlayer();
      }

      if (!scriptElement$1) {
        loadScript$1();
      }

      scriptElement$1.addEventListener('load', function () {
        _this2._createPlayer();
      });
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      var _this3 = this;

      this._validateProps();

      var updatedPropsExceptMedia = Object.keys(prevProps).reduce(function (updated, prop) {
        if (mediaProps.includes(prop)) {
          return updated;
        }

        if (prevProps[prop] !== _this3.props[prop]) {
          updated.push(prop);
        }
        return updated;
      }, []);

      if (updatedPropsExceptMedia.length > 0) {
        this.player = null;
        document.getElementById(prevProps.id).innerHTML = '';
        return this._createPlayer();
      }

      if (prevProps.channel !== this.props.channel && this.props.channel) {
        return this.player.setChannel(this.props.channel);
      }

      if (prevProps.collection !== this.props.collection && this.props.collection) {
        this.player.setCollection(this.props.collection);
      }

      if (prevProps.video !== this.props.video && this.props.video) {
        this.player.setVideo('v' + this.props.video);
      }
    }
  }, {
    key: '_createPlayer',
    value: function _createPlayer() {
      var options = {
        height: '100%',
        width: '100%',
        playsinline: this.props.playsInline,
        allowfullscreen: this.props.allowFullscreen,
        autoplay: this.props.autoplay,
        muted: this.props.muted,
        time: this.props.time,
        controls: !this.props.hideControls,
        parent: this.props.parent
      };

      if (this.props.channel) {
        options.channel = this.props.channel;
      }

      if (this.props.video) {
        options.video = this.props.video;
      }

      if (this.props.collection) {
        options.collection = this.props.collection;
      }

      this.player = new window.Twitch.Player(this.props.id, options);
      this._addEventListeners();
    }
  }, {
    key: '_addEventListeners',
    value: function _addEventListeners() {
      var _this4 = this;

      this.player.addEventListener(window.Twitch.Player.ENDED, this.props.onEnded);
      this.player.addEventListener(window.Twitch.Player.PAUSE, this.props.onPause);
      this.player.addEventListener(window.Twitch.Player.PLAY, this.props.onPlay);
      this.player.addEventListener(window.Twitch.Player.PLAYBACK_BLOCKED, this.props.onPlaybackBlocked);
      this.player.addEventListener(window.Twitch.Player.PLAYING, this.props.onPlaying);
      this.player.addEventListener(window.Twitch.Player.OFFLINE, this.props.onOffline);
      this.player.addEventListener(window.Twitch.Player.ONLINE, this.props.onOnline);
      this.player.addEventListener(window.Twitch.Player.READY, function () {
        _this4.props.onReady(_this4.player);
      });
    }
  }, {
    key: '_validateProps',
    value: function _validateProps() {
      var _props = this.props,
          channel = _props.channel,
          collection = _props.collection,
          video = _props.video;


      if (!channel && !collection && !video) {
        throw new Error('A channel, collection or video prop must be supplied to TwitchPlayer!');
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var unknownProps = getUnknownProps(this.props, propTypes$3);

      return React__default.createElement('div', _extends({ id: this.props.id, style: { width: this.props.width, height: this.props.height } }, unknownProps));
    }
  }]);
  return TwitchPlayer;
}(React.Component);

TwitchPlayer.propTypes = propTypes$3;
TwitchPlayer.defaultProps = defaultProps$3;

exports.TwitchEmbed = TwitchEmbed;
exports.TwitchChat = TwitchChat;
exports.TwitchClip = TwitchClip;
exports.TwitchPlayer = TwitchPlayer;
//# sourceMappingURL=index.js.map
